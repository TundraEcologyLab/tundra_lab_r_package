#' Extract from adjacent cell to label
#'
#' A function designed for use specifically with the fill_parameter function. fill_parameter,
#' when given this extractor function, will return whatever data is found located one cell
#' to the right of the label, if the label is found. For this use, the meta_only parameter
#' should be set to TRUE and full_existing_check set to FALSE. If string is a character vector
#' of length greater than one then a character vector of hits from all strings is returned.
#' @param string A character string that will be checked for the presence of the label, and
#' from which the data will be extracted if the label is present. The character string will
#' be generated by loading the dataframe using read.lines, otherwise it may not be in the right
#' format. fill_parameter takes care of this for you.
#' @param label A regex expression (can be treated as a character string if special characters are
#' avoided) that will match what should be found to the left of the data completely
#' @param ignore.case should the search return a hit regardless if in upper or lower case. Defaults
#' to TRUE

adjacent_extractor <- function(string, label, ignore.case = TRUE){
    # If there is not more than one string then perform extraction
    if (length(string) == 1){
        # Set hit to NULL
        hit <- NULL
        # If the label is present in the string then extract the data in adjacent cell
        if (grepl(label, string, ignore.case = ignore.case)){
            # The regex relies on being fed data where the fields are separated by commas. and
            # the label is encapsulated in inverted commas. This is the format found when read.lines
            # reads a csv file and the label is a string, which seems likely. If the first character
            # of the adjacent cell is " then everything from there until the next " is extracted, else
            # everything until the next comma is extracted

            # If adjacent cell contains a string extract everything in string
            if (grepl(paste0(label, '","'), string, ignore.case = ignore.case)){
                hit <- sub(paste0(".*", label, '"?,"([^"]*).*'), "\\1", string, ignore.case = ignore.case)
            } else { # If adjacent cell is not a string, extract whole cell
                hit <- sub(paste0(".*", label, '"?,([^,]*).*'), "\\1", string, ignore.case = ignore.case)
            }
            # If hit == string then no hit was extracted. Potentially the label was the final cell. Return NULL
            if (identical(string, hit)){
                hit <- NULL
            }
        }
        # If there is more than one string then call this function separately on each and return
        # all hits
    } else if (length(string) > 1){
        hit <- lapply(string, adjacent_extractor, label = label, ignore.case = ignore.case)
        hit <- unlist(hit)
        # If string is of length 0 then return NULL
    } else {
        hit <- NULL
    }
    hit
}
